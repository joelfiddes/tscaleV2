plot(hrmm, type='l')
lines(mm,col='red')
}
}
for ( i in 1:length(a) ){
hrmm = a[[i]]$x
mm = tpmm4[i,]
for (i in 1:10){
plot(hrmm, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
}
for ( i in 1:length(a) ){
hrmm = a[[i]]$x
mm = tpmm4[i,]
for (i in 1:10){
plot(hrmm*6, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
}
for ( i in 1:length(a) ){
hrmm = a[[i]]$x*6
mm = tpmm4[i,]
cf =mm/hrmm
for (i in 1:10){
plot(hrmm, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
}
cfl=c()
for ( i in 1:length(a) ){
hrmm = a[[i]]$x*6
mm = tpmm4[i,]
cfl =c(cfl,mm/hrmm)
plot(hrmm, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
cfl
for ( i in 1:length(a) ){
hrmm = a[[i]]$x*6
mm = tpmm4[i,]
cfl[i]<-(mm/hrmm)
plot(hrmm, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
warnings()
str(cfl)
cfl[[i]]<-(mm/hrmm)
for ( i in 1:length(a) ){
hrmm = a[[i]]$x*6
mm = tpmm4[i,]
cfl[[i]]<-(mm/hrmm)
plot(hrmm, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
rm(cfl)
for ( i in 1:length(a) ){
hrmm = a[[i]]$x*6
mm = tpmm4[i,]
cfl[[i]]<-(mm/hrmm)
plot(hrmm, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
for ( i in 1:length(a) ){
hrmm = a[[i]]$x*6
mm = tpmm4[i,]
cfl[[i]]<-(mm/hrmm)
plot(hrmm, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
cfl=c()
for ( i in 1:length(a) ){
hrmm = a[[i]]$x*6
mm = tpmm4[i,]
cfl[[i]]<-(mm/hrmm)
plot(hrmm, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
str(CFL)
str(cfl)
cflm = as.matrix(cfl)
cflm
str(CFLM)
str(cflm)
str(cflm)
cfl[[1]]
cfl[[1]]*hrmm*6
a =cfl[[1]]*hrmm*6
identical(a, mm[1]
)
identical(a, mm[[1]]
)
a
mm[1]
mm
identical(a, tpmm4[[1,]]
)
identical(a, tpmm4[1,])
a =cfl[[1]]*hrmm
identical(a, tpmm4[1,])
identical(a, a[[1]]$x*6)
identical(a, a[[1]]$x*6)
cfl=c()
for ( i in 1:length(a) ){
hrmm = a[[i]]$x*6
mm = tpmm4[i,]
cfl[[i]]<-(mm/hrmm)
plot(hrmm, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
a =apply(tphr,c(1,2), 'aggregate', list(mo), sum )
plot(tpmm3[1,1,], type='l')
lines(a[[1]]$x, type='l', col='red')
# check sums
sum(tpmm3)
sum(tphr*6)
sum(as.numeric(as.vector(unlist(a))),na.rm=T)*6
# flatten
tpmm4 = matrix(tpmm3, 180, 62)
# generates list of monthly correction factors
cfl=c()
for ( i in 1:length(a) ){
hrmm = a[[i]]$x*6
mm = tpmm4[i,]
cfl[[i]]<-(mm/hrmm)
plot(hrmm, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
identical(mm, hrmm*cfl)
identical(mm, hrmm*(mm/hrmm))
identical(mm, hrmm*(mm/hrmm))
str(cfl)
str(tphr)
dim(tphr
)
length(a)
str(monthLengthVec)
str(monthLengthVec[8:69])
myrep = rep(cfl[i],monthLengthVec[8:69])
myrep = rep(cfl[i],times=monthLengthVec[8:69])
myrep = rep(cfl[i],each=monthLengthVec[8:69])
cfl[i]
myrep
cfl[i]
length(monthLengthVec[8:69])
rep(cfl[i],times = monthLengthVec[8:69])
monthLengthVec[8:69]
rep(cfl[i],times = monthLengthVec[8:69])
rep(x =cfl[i],times = monthLengthVec[8:69])
rep(x =cfl[i],times = c(monthLengthVec[8:69]))
monthLengthVec[8:69]
monthLengthVec[8:69]cfl[1]
cfl[1]
rep(x =cfl[i],c(monthLengthVec[8:69]))
a =monthLengthVec[8:69]
rep(x =cfl[i],a)
rep(cfl[i],a)
b =cfl[i]
b
rep(b,a)
a
str(a)
str(b)
rep(as.vector(b),a)
str(as.vector(b))
str(unlist(b))
rep(unlist(b),a)
rep(unlist(b),a)
tpHr
str(tph_flat)
str(tph_flat)
tph_flat = matrix(tphr, dim(tphr)[1]*dim(tphr)[2], dim(tphr)[1])
str(tph_flat)
# flsatten six hour data matrix
tph_flat = matrix(tphr, dim(tphr)[1]*dim(tphr)[2], dim(tphr)[3])
str(tph_flat)
length(corVec)
corVec = rep(unnlist(cfl[i]),times = monthLengthVec[8:69])
corVec = rep(unlist(cfl[i]),times = monthLengthVec[8:69])
length(corVec)
365*5
 monthLengthVec[8:69]
str(tph)
str(tphr)
24/6
monthLengthVec[startMonth:endMonth]*dailyCount
monthLengthVec[startMonth:endMonth]*dailyCount
timeStep =6
startMonth = 8 # defines cut of monthly jan-Dec data to simulation Sept-sept
endMonth=69 # defines cut
mmfile="/home/joel/sim/imis/forcing/tpmm.nc"
t6hfile = "/home/joel/sim/imis/forcing/SURF.nc"
monthLengthVec[startMonth:endMonth]*dailyCount
monthLengthVec[startMonth:endMonth]*dailyCount
dailyCount = 24 / timestep # counts per day
timestep =6
dailyCount = 24 / timestep # counts per day
monthLengthVec[startMonth:endMonth]*dailyCount
corVec = rep(unlist(cfl[i]),times = monthLengthVec[startMonth:endMonth]*dailyCount)
corVec
str(tph_flat)
corVec*tph_flat[i,]
corVec*tph_flat[i,]
tail(corVec)
tail(tph_flat[i])
tail(tph_flat[i],)
tail(tph_flat[i,])
6.246652e-06
6.246652e-06*0.96
plot(tph_flat[i,], type='l')
lines(corVecec*tph_flat[i,], col='red')
lines(corVec*tph_flat[i,], col='red')
plot(tph_flat[i,1:100], type='l')
lines(corVec[1:100]*tph_flat[i,1:100], col='red')
ntimes=tph_flat[i,]- corVec
ntimes
ntimes=tph_flat[i,]- corVec
ntimes=length(tph_flat[i,])- length(corVec
)
ntimes
rep(corVec[length(corVec)], ntimes)
corVec = c(corVec, rep(corVec[length(corVec)], ntimes))
lines(corVecec*tph_flat[i,], col='red')
lines(corVec*tph_flat[i,], col='red')
lines(corVec*tph_flat[i,], col='blue')
str(corP)
corP = corVec*tph_flat[i,]
str(corP)
str(tphr)
corP=c()
for ( i in 1:length(a) ){
# correction vector same length as hourly data
corVec = rep(unlist(cfl[i]),times = monthLengthVec[startMonth:endMonth]*dailyCount)
# in case of unequal vecytors this means one or more leap years is present in dataset
# implementing these would be costly so just recyle last element now - of course this can lead to shift of up to 10 days in case of full era record
# needs attention!!
if (length(corVec)!=length(tph_flat[i,]) ){
ntimes=length(tph_flat[i,])- length(corVec)
# paste replicates of last correction factor to extend timeseries
corVec = c(corVec, rep(corVec[length(corVec)], ntimes))
}
# timeseries for grid i of corrected 6 h data adjusted by monthly totals
corP = c(corP,corVec*tph_flat[i,])
}
corP
 corP_array = matrix(corP  dim(tpmm4)[1] ,dim(tpmm4)[2], dim(tpmm4)[3])
 corP_array = matrix(corP  ,dim(tpmm4)[1] ,dim(tpmm4)[2], dim(tpmm4)[3])
 corP_array = array(corP  ,dim(tpmm4)[1] ,dim(tpmm4)[2], dim(tpmm4)[3])
 corP_array = array(corP  ,dim= c(dim(tpmm4)[1] ,dim(tpmm4)[2], dim(tpmm4)[3]))
 dim(tpmm4)[3]
 dim(tpmm4)[2]
 dim(tpmm4)[1]
# number of years in monthly data
nyears=dim(tpmm)[3]/12
# number of days per month vec, ignore leap years pain in ass to implement and insignificant error
monthLengthVec = rep(c(31,28,31,30,31,30,31,31,30,31,30,31),nyears) 
# weighted by days in the month
tpmm2 =tpmm*monthLengthVec
# cut to length of obs 
tpmm3 = tpmm2[,,startMonth:endMonth]
nc1=nc_open(t6hfile)
time = ncvar_get( nc1,'time')
z <- time*60*60 #make seconds
origin = unlist(strsplit(nc1$dim$time$units, " "))[[3]]
datesHr<-ISOdatetime(origin,0,0,0,0,0,tz='UTC') + z #dates sequence
tphr = ncvar_get( nc1,'tp')
# make monthly totals of subdaily data
mo =substr(datesHr, 1,7)
a =apply(tphr,c(1,2), 'aggregate', list(mo), sum )
plot(tpmm3[1,1,], type='l')
lines(a[[1]]$x, type='l', col='red')
# check sums
sum(tpmm3)
sum(tphr*timestep)
sum(as.numeric(as.vector(unlist(a))),na.rm=T)*timestep
# flatten
tpmm4 = matrix(tpmm3,  dim(tpmm4)[1]*dim(tpmm4)[2], dim(tpmm4)[3])
# generates list of monthly correction factors
cfl=c()
for ( i in 1:length(a) ){
hrmm = a[[i]]$x*timestep
mm = tpmm4[i,]
cfl[[i]]<-(mm/hrmm)
plot(hrmm, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
# flatten six hour data matrix
tph_flat = matrix(tphr, dim(tphr)[1]*dim(tphr)[2], dim(tphr)[3])
corP=c()
for ( i in 1:length(a) ){
# correction vector same length as hourly data
corVec = rep(unlist(cfl[i]),times = monthLengthVec[startMonth:endMonth]*dailyCount)
# in case of unequal vecytors this means one or more leap years is present in dataset
# implementing these would be costly so just recyle last element now - of course this can lead to shift of up to 10 days in case of full era record
# needs attention!!
if (length(corVec)!=length(tph_flat[i,]) ){
ntimes=length(tph_flat[i,])- length(corVec)
# paste replicates of last correction factor to extend timeseries
corVec = c(corVec, rep(corVec[length(corVec)], ntimes))
}
# timeseries for grid i of corrected 6 h data adjusted by monthly totals
corP = c(corP,corVec*tph_flat[i,])
}
dim(tpmm4)[3]
# flatten
tpmm4 = matrix(tpmm3,  dim(tpmm3)[1]*dim(tpmm3)[2], dim(tpmm3)[3])
# generates list of monthly correction factors
cfl=c()
for ( i in 1:length(a) ){
hrmm = a[[i]]$x*timestep
mm = tpmm4[i,]
cfl[[i]]<-(mm/hrmm)
plot(hrmm, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
# flatten six hour data matrix
tph_flat = matrix(tphr, dim(tphr)[1]*dim(tphr)[2], dim(tphr)[3])
corP=c()
for ( i in 1:length(a) ){
# correction vector same length as hourly data
corVec = rep(unlist(cfl[i]),times = monthLengthVec[startMonth:endMonth]*dailyCount)
# in case of unequal vecytors this means one or more leap years is present in dataset
# implementing these would be costly so just recyle last element now - of course this can lead to shift of up to 10 days in case of full era record
# needs attention!!
if (length(corVec)!=length(tph_flat[i,]) ){
ntimes=length(tph_flat[i,])- length(corVec)
# paste replicates of last correction factor to extend timeseries
corVec = c(corVec, rep(corVec[length(corVec)], ntimes))
}
# timeseries for grid i of corrected 6 h data adjusted by monthly totals
corP = c(corP,corVec*tph_flat[i,])
}
corP_array = matrix(corP , dim = c(dim(tpmm4)[1] ,dim(tpmm4)[2], dim(tpmm4)[3] ) )
corP_array = array(corP , dim = c(dim(tpmm4)[1] ,dim(tpmm4)[2], dim(tpmm4)[3] ) )
dim(tpmm4)
corP_array = matrix(corP , dim = c(dim(tpmm3)[1] ,dim(tpmm3)[2], dim(tpmm3)[3] ) )
corP_array = array(corP , dim = c(dim(tpmm3)[1] ,dim(tpmm3)[2], dim(tpmm3)[3] ) )
corP_array
str(corP_array)
str(corP)
length(tph_flat[1,])
str(tphr
)
corP_array = array(corP , dim = c(dim(tphr)[1] ,dim(tphr)[2], dim(tphr)[3] ) )
str(corP_array)
plot(corP_array[1,1,])
plot(corP_array[1,1,], type='l')
plot(corP_array[1,1,], type='l', col='red')
plot(corP_array[1,1,], type='l')
lines(tphr[1,1,], type='l', col='red')
plot(corP_array[1,1,], tphr[1,1,])
str(corP_array)
str(tphr)
plot(corP[1:7548], tphr[1,1,])
str(tp_flat)
str(tph_flat)
plot(tphr_flat[1,], tphr[1,1,])
plot(tph_flat[1,], tphr[1,1,])
plot(corP[1:7548], tphr[1,1,])
?array
plot(tphr_flat[1,], tphr[1,1,])
plot(tphr_flat[1,], tphr[1,1,])
plot(corP[1:7548], tphr[1,1,])
corP_array = array(corP , dim = c(dim(tphr)[2] ,dim(tphr)[1], dim(tphr)[3] ) )
plot(corP_array[1,1], tphr[1,1,])
plot(corP_array[1,1,], tphr[1,1,])
corP_array = array(corP , dim = c(dim(tphr)[1] ,dim(tphr)[2], dim(tphr)[3] ) )
plot(corP_array[1,1,], tphr[1,1,])
corP_array = array(corP , dim = c(dim(tphr)[1] ,dim(tphr)[2], dim(tphr)[3] ) )
plot(corP_array[1,1,], tphr[1,1,])
plot(corP_array[1,2,], tphr[1,1,])
plot(corP_array[1,1,], tphr[1,1,])
corP_array = array(corP , dim = c(dim(tphr)[1] ,dim(tphr)[2], dim(tphr)[3] ) )
str(corP)
z = corVec*tph_flat[i,]
str(z)
corP_array = array(corP , dim = c(dim(tphr)[1] *dim(tphr)[2], dim(tphr)[3] ) )
str(corP_array)
str(tph_flat)
plot(corP_array[1,], typ='l')
lines(tph_flat[1,], col='red')
plot(corP_array[1,1;100], typ='l')
plot(corP_array[1,1:100], typ='l')
lines(tph_flat[1,1:100], col='red')
corP_array = matrix(corP , dim(tphr)[1] *dim(tphr)[2], dim(tphr)[3] )
plot(corP_array[1,1:100], typ='l')
lines(tph_flat[1,1:100], col='red')
# the idea is to download 4h tp then correct by monthly means to account for full monthly budget
# monthly means are super fast to download (smaller data and faster server "spinning disks!")
# same idea for cmip5 (monthly cc signal)
# all data? 1 year of hourly distribution, scale by monthly means - run this past seb!!
# documented era5 hgere: https://confluence.ecmwf.int/display/CKB/ERA5+data+documentation#ERA5datadocumentation-Monthlymeans
#values are mean daily for that month, weight by number of days in month eg annualtotal = sum(wfj_m*c(31,28,31,30,31,30,31,31,30,31,30,31))
# THIS IS THE
require(ncdf4)
require(raster)
# pars 
timestep =6
startMonth = 8 # defines cut of monthly jan-Dec data to simulation Sept-sept
endMonth=69 # defines cut
mmfile="/home/joel/sim/imis/forcing/tpmm.nc"
t6hfile = "/home/joel/sim/imis/forcing/SURF.nc"
# code start ==============
dailyCount = 24 / timestep # counts per day
# get monthly dates
nc=nc_open(mmfile)
time = ncvar_get( nc,'time')
z <- time*60*60 #make seconds
origin = unlist(strsplit(nc$dim$time$units, " "))[[3]]
datesMonth<-ISOdatetime(origin,0,0,0,0,0,tz='UTC') + z #dates sequence
tpmm = ncvar_get( nc,'tp')
# number of years in monthly data
nyears=dim(tpmm)[3]/12
# number of days per month vec, ignore leap years pain in ass to implement and insignificant error
monthLengthVec = rep(c(31,28,31,30,31,30,31,31,30,31,30,31),nyears) 
# weighted by days in the month
tpmm2 =tpmm*monthLengthVec
# cut to length of obs 
tpmm3 = tpmm2[,,startMonth:endMonth]
nc1=nc_open(t6hfile)
time = ncvar_get( nc1,'time')
z <- time*60*60 #make seconds
origin = unlist(strsplit(nc1$dim$time$units, " "))[[3]]
datesHr<-ISOdatetime(origin,0,0,0,0,0,tz='UTC') + z #dates sequence
tphr = ncvar_get( nc1,'tp')
# make monthly totals of subdaily data
mo =substr(datesHr, 1,7)
# hourly data aggregated as monthly mean
a =apply(tphr,c(1,2), 'aggregate', list(mo), sum )
plot(tpmm3[1,1,], type='l')
lines(a[[1]]$x, type='l', col='red')
# check sums
sum(tpmm3)
sum(tphr*timestep)
sum(as.numeric(as.vector(unlist(a))),na.rm=T)*timestep
# flatten
tpmm4 = matrix(tpmm3,  dim(tpmm3)[1]*dim(tpmm3)[2], dim(tpmm3)[3])
# generates list of monthly correction factors
cfl=c()
for ( i in 1:length(a) ){
hrmm = a[[i]]$x*timestep
mm = tpmm4[i,]
cfl[[i]]<-(mm/hrmm)
plot(hrmm, type='l', ylim=c(0,0.5))
lines(mm,col='red')
}
# flatten six hour data matrix
tph_flat = matrix(tphr, dim(tphr)[1]*dim(tphr)[2], dim(tphr)[3])
corP=c()
for ( i in 1:length(a) ){
# correction vector same length as hourly data
corVec = rep(unlist(cfl[i]),times = monthLengthVec[startMonth:endMonth]*dailyCount)
# in case of unequal vecytors this means one or more leap years is present in dataset
# implementing these would be costly so just recyle last element now - of course this can lead to shift of up to 10 days in case of full era record
# needs attention!!
if (length(corVec)!=length(tph_flat[i,]) ){
ntimes=length(tph_flat[i,])- length(corVec)
# paste replicates of last correction factor to extend timeseries
corVec = c(corVec, rep(corVec[length(corVec)], ntimes))
}
# timeseries for grid i of corrected 6 h data adjusted by monthly totals
corP = c(corP,corVec*tph_flat[i,])
}
corP_array = matrix(corP , dim(tphr)[1] *dim(tphr)[2], dim(tphr)[3] )
plot(corP_array[1,1:100], typ='l')
lines(tph_flat[1,1:100], col='red')
## test for 2015
#startHr =which(datesHr==strptime("2014-01-01 00:00:00", "%Y-%m-%d", tz="UTC"))
#endHr = which(datesHr==strptime("2014-12-31 18:00:00", "%Y-%m-%d", tz="UTC"))
#startM = 421#which(datesMonth=="2015-01-01 UTC") = 433
#endM = 432#which(datesMonth=="2015-12-01") =444
## extract points
#wfj_m = extract(tp,shp)[1,startM:endM]
#wfj_h = extract(tp_3hr[[startHr:endHr]],shp)
##x =sum(tp[[startM:endM]])
##x2 = sum(tp_hr[[startHr:endHr]])
## monthly means total
#anntotal = sum(wfj_m*c(31,28,31,30,31,30,31,31,30,31,30,31))
#anntotal
##1.389376
## sum of hourly values
#sum(wfj_h[1,])*3
##mm = 
##6h *6 = 1.332941
##3h*3
##1h
##t1hfile1 = 0.854133
##1.291304
## sum of 6h vals simply scaled*6
##b1 <- a[seq(1, length(a), 6)]
##> sum(b1)*6
##[1] 1.256834
##corfact = anntotal/(sum(b1)*6)
##sum(b1)*6*corfact
##[1] 1.311794
##[1] 1.311794
plot(corP_array[1,1:100], typ='l')
lines(tph_flat[1,1:100], col='red')
plot(corP[1:100], typ='l')
lines(tph_flat[1,1:100], col='red')
?matrix
corP_array = matrix(corP , dim(tphr)[1] *dim(tphr)[2], dim(tphr)[3] ,byrow=T)
plot(corP_array[1,1:100], typ='l')
lines(tph_flat[1,1:100], col='red')
?array
corP_array2 = array(corP_array , dim = c(dim(tphr)[1] ,dim(tphr)[2], dim(tphr)[3]))
plot(corP_array2[1,1, 1:100], typ='l')
lines(tph_flat[1,1:100], col='red')
plot(corP_array2[1,1, 1:100], typ='l')
lines(tph[1,1, 1:100], col='red')
plot(corP_array2[1,1, 1:100], typ='l')
lines(tphr[1,1, 1:100], col='red')
